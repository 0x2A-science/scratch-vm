{"version":3,"file":"motion-extension.js","sources":["webpack:///webpack/bootstrap 7fb9cfadad1c4941c3dc","webpack:///(webpack)/buildin/global.js","webpack:///src/extensions/scratch3_video_sensing/debug.js","webpack:///./src/extensions/scratch3_video_sensing/debug.js","webpack:///src/extensions/scratch3_video_sensing/view.js","webpack:///src/extensions/scratch3_video_sensing/lib.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 363);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7fb9cfadad1c4941c3dc","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0 1 2","module.exports = global[\"Scratch3MotionDetect\"] = require(\"-!./debug.js\");\n\n\n// WEBPACK FOOTER //\n// src/extensions/scratch3_video_sensing/debug.js","const VideoMotion = require('./lib');\nconst VideoMotionView = require('./view');\n\nmodule.exports = {\n    VideoMotion,\n    VideoMotionView\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/extensions/scratch3_video_sensing/debug.js\n// module id = 364\n// module chunks = 2","const WIDTH = 480;\nconst HEIGHT = 360;\nconst WINSIZE = 8;\nconst AMOUNT_SCALE = 100;\nconst THRESHOLD = 10;\n\nconst OUTPUT = {\n    INPUT: -1,\n    XYT: 0,\n    XYT_CELL: 1,\n    XY: 2,\n    XY_CELL: 3,\n    T: 4,\n    T_CELL: 5,\n    C: 6,\n    AB: 7,\n    UV: 8\n};\n\nclass VideoMotionView {\n    constructor (motion, output = OUTPUT.XYT) {\n        this.motion = motion;\n\n        const canvas = this.canvas = document.createElement('canvas');\n        canvas.width = WIDTH;\n        canvas.height = HEIGHT;\n        this.context = canvas.getContext('2d');\n\n        this.output = output;\n        this.buffer = new Uint32Array(WIDTH * HEIGHT);\n    }\n\n    static get OUTPUT () {\n        return OUTPUT;\n    }\n\n    _eachAddress (xStart, yStart, xStop, yStop, fn) {\n        for (let i = yStart; i < yStop; i++) {\n            for (let j = xStart; j < xStop; j++) {\n                const address = (i * WIDTH) + j;\n                fn(address, j, i);\n            }\n        }\n    }\n\n    _eachCell (xStart, yStart, xStop, yStop, xStep, yStep, fn) {\n        const xStep2 = (xStep / 2) | 0;\n        const yStep2 = (yStep / 2) | 0;\n        for (let i = yStart; i < yStop; i += yStep) {\n            for (let j = xStart; j < xStop; j += xStep) {\n                fn(\n                    _fn => this._eachAddress(j - xStep2 - 1, i - yStep2 - 1, j + xStep2, i + yStep2, _fn),\n                    j - xStep2 - 1,\n                    i - yStep2 - 1,\n                    j + xStep2,\n                    i + yStep2\n                );\n            }\n        }\n    }\n\n    _grads (address) {\n        const {curr, prev} = this.motion;\n        const gradX = (curr[address - 1] & 0xff) - (curr[address + 1] & 0xff);\n        const gradY = (curr[address - WIDTH] & 0xff) - (curr[address + WIDTH] & 0xff);\n        const gradT = (prev[address] & 0xff) - (curr[address] & 0xff);\n        return {gradX, gradY, gradT};\n    }\n\n    draw () {\n        if (!(this.motion.prev && this.motion.curr)) {\n            return;\n        }\n\n        const {buffer} = this;\n\n        if (this.output === OUTPUT.INPUT) {\n            const {curr} = this.motion;\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                buffer[address] = curr[address];\n            });\n        }\n        if (this.output === OUTPUT.XYT) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                const over1 = gradT / 0xcf;\n                buffer[address] =\n                    (0xff << 24) +\n                    (Math.floor((((gradY * over1) & 0xff) + 0xff) / 2) << 8) +\n                    Math.floor((((gradX * over1) & 0xff) + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XYT_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY, gradT} = this._grads(address);\n                    C2 += (Math.max(Math.min(gradX / 0x0f, 1), -1)) * (gradT / 0xff);\n                    C1 += (Math.max(Math.min(gradY / 0x0f, 1), -1)) * (gradT / 0xff);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        }\n        if (this.output === OUTPUT.XY) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] = (0xff << 24) + (((gradY + 0xff) / 2) << 8) + ((gradX + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XY_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY} = this._grads(address);\n                    C2 += Math.max(Math.min(gradX / 0x1f, 1), -1);\n                    C1 += Math.max(Math.min(gradY / 0x1f, 1), -1);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        } else if (this.output === OUTPUT.T) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradT} = this._grads(address);\n                buffer[address] = (0xff << 24) + ((gradT + 0xff) / 2 << 16);\n            });\n        }\n        if (this.output === OUTPUT.T_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let T = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradT} = this._grads(address);\n                    T += gradT / 0xff;\n                    n += 1;\n                });\n\n                T /= n;\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((T * 0x7f) | 0) + 0x80) << 16) & 0xff0000);\n                });\n            });\n        } else if (this.output === OUTPUT.C) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    ((gradY * gradT) << 8) +\n                    (gradX * gradT);\n            });\n        } else if (this.output === OUTPUT.AB) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    ((gradX * gradY) << 16) +\n                    ((gradY * gradY) << 8) +\n                    (gradX * gradX);\n            });\n        } else if (this.output === OUTPUT.UV) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let A2 = 0;\n                let A1B2 = 0;\n                let B1 = 0;\n                let C2 = 0;\n                let C1 = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY, gradT} = this._grads(address);\n                    A2 += gradX * gradX;\n                    A1B2 += gradX * gradY;\n                    B1 += gradY * gradY;\n                    C2 += gradX * gradT;\n                    C1 += gradY * gradT;\n                });\n\n                const delta = ((A1B2 * A1B2) - (A2 * B1));\n                let u = 0;\n                let v = 0;\n                if (delta) {\n                    /* system is not singular - solving by Kramer method */\n                    const deltaX = -((C1 * A1B2) - (C2 * B1));\n                    const deltaY = -((A1B2 * C2) - (A2 * C1));\n                    const Idelta = 8 / delta;\n                    u = deltaX * Idelta;\n                    v = deltaY * Idelta;\n                } else {\n                    /* singular system - find optical flow in gradient direction */\n                    const Norm = ((A1B2 + A2) * (A1B2 + A2)) + ((B1 + A1B2) * (B1 + A1B2));\n                    if (Norm) {\n                        const IGradNorm = 8 / Norm;\n                        const temp = -(C1 + C2) * IGradNorm;\n                        u = (A1B2 + A2) * temp;\n                        v = (B1 + A1B2) * temp;\n                    }\n                }\n\n                const inRange = (-winStep < u && u < winStep && -winStep < v && v < winStep);\n                const hypot = Math.hypot(u, v);\n                const amount = AMOUNT_SCALE * hypot;\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        (inRange && amount > THRESHOLD ?\n                            (((((v / winStep) + 1) / 2 * 0xff) << 8) & 0xff00) +\n                            (((((u / winStep) + 1) / 2 * 0xff) << 0) & 0xff) :\n                            0x8080\n                        );\n                });\n            });\n        }\n\n        const data = new ImageData(new Uint8ClampedArray(this.buffer.buffer), WIDTH, HEIGHT);\n        this.context.putImageData(data, 0, 0);\n    }\n}\n\nmodule.exports = VideoMotionView;\n\n\n\n// WEBPACK FOOTER //\n// src/extensions/scratch3_video_sensing/view.js","/**\n * lib.js\n *\n * Tony Hwang and John Maloney, January 2011\n * Michael \"Z\" Goddard, March 2018\n *\n * Video motion sensing primitives.\n */\n\nconst TO_DEGREE = 180 / Math.PI;\nconst WIDTH = 480;\nconst HEIGHT = 360;\n// chosen empirically to give a range of roughly 0-100\nconst AMOUNT_SCALE = 100;\n// note 2e-4 * activePixelNum is an experimentally tuned threshold for my\n// logitech Pro 9000 webcam - TTH\nconst LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;\nconst THRESHOLD = 10;\nconst WINSIZE = 8;\nconst LOCAL_MAX_AMOUNT = 100;\nconst LOCAL_THRESHOLD = THRESHOLD / 3;\n\nconst STATE_KEY = 'Scratch.videoSensing';\n\nclass VideoMotion {\n    constructor () {\n        this.frameNumber = 0;\n        this.motionAmount = 0;\n        this.motionDirection = 0;\n        this.analysisDone = false;\n\n        this.curr = null;\n        this.prev = null;\n\n        this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);\n        this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);\n        this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);\n    }\n\n    reset () {\n        this.prev = this.curr = null;\n        this.motionAmount = this.motionDirection = 0;\n        this.analysisDone = true;\n\n        const targets = this.runtime.targets;\n        for (let i = 0; i < targets.length; i++) {\n            targets[i].getCustomState(STATE_KEY).motionAmount = 0;\n            targets[i].getCustomState(STATE_KEY).motionDirection = 0;\n        }\n    }\n\n    addFrame (source) {\n        this.frameNumber++;\n\n        this.prev = this.curr;\n        this.curr = new Uint32Array(source.buffer.slice());\n\n        const _tmp = this._prev;\n        this._prev = this._curr;\n        this._curr = _tmp;\n        for (let i = 0; i < this.curr.length; i++) {\n            this._curr[i] = this.curr[i] & 0xff;\n        }\n\n        this.analysisDone = false;\n    }\n\n    analyzeFrame () {\n        if (!this.curr || !this.prev) {\n            this.motionAmount = this.motionDirection = -1;\n            // don't have two frames to analyze yet\n            return;\n        }\n\n        const {\n            _curr: curr,\n            _prev: prev\n        } = this;\n\n        const winStep = (WINSIZE * 2) + 1;\n        const wmax = WIDTH - WINSIZE - 1;\n        const hmax = HEIGHT - WINSIZE - 1;\n\n        let uu = 0;\n        let vv = 0;\n        let n = 0;\n\n        for (let i = WINSIZE + 1; i < hmax; i += winStep) {\n            for (let j = WINSIZE + 1; j < wmax; j += winStep) {\n                let A2 = 0;\n                let A1B2 = 0;\n                let B1 = 0;\n                let C1 = 0;\n                let C2 = 0;\n\n                let address = ((i - WINSIZE) * WIDTH) + j - WINSIZE;\n                let nextAddress = address + winStep;\n                const maxAddress = ((i + WINSIZE) * WIDTH) + j + WINSIZE;\n                for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {\n                    for (; address <= nextAddress; address += 1) {\n                        const gradT = ((prev[address]) - (curr[address]));\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                    }\n                }\n\n                const delta = ((A1B2 * A1B2) - (A2 * B1));\n                let u = 0;\n                let v = 0;\n                if (delta) {\n                    // system is not singular - solving by Kramer method\n                    const deltaX = -((C1 * A1B2) - (C2 * B1));\n                    const deltaY = -((A1B2 * C2) - (A2 * C1));\n                    const Idelta = 8 / delta;\n                    u = deltaX * Idelta;\n                    v = deltaY * Idelta;\n                } else {\n                    // singular system - find optical flow in gradient direction\n                    const Norm = ((A1B2 + A2) * (A1B2 + A2)) + ((B1 + A1B2) * (B1 + A1B2));\n                    if (Norm) {\n                        const IGradNorm = 8 / Norm;\n                        const temp = -(C1 + C2) * IGradNorm;\n                        u = (A1B2 + A2) * temp;\n                        v = (B1 + A1B2) * temp;\n                    }\n                }\n\n                if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n                    uu += u;\n                    vv += v;\n                    n++;\n                }\n            }\n        }\n\n        uu /= n;\n        vv /= n;\n        this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));\n        if (this.motionAmount > THRESHOLD) {\n            // Scratch direction\n            this.motionDirection = (((Math.atan2(vv, uu) * TO_DEGREE) + 270) % 360) - 180;\n        }\n        this.analysisDone = true;\n    }\n\n    getLocalMotion (drawable, state) {\n        if (!this.curr || !this.prev) {\n            state.motionAmount = state.motionDirection = -1;\n            // don't have two frames to analyze yet\n            return;\n        }\n        if (state.motionFrameNumber !== this.frameNumber) {\n            const {\n                _prev: prev,\n                _curr: curr\n            } = this;\n\n            const boundingRect = drawable.getFastBounds();\n            const xmin = Math.floor(boundingRect.left + (WIDTH / 2));\n            const xmax = Math.floor(boundingRect.right + (WIDTH / 2));\n            const ymin = Math.floor((HEIGHT / 2) - boundingRect.top);\n            const ymax = Math.floor((HEIGHT / 2) - boundingRect.bottom);\n\n            let A2 = 0;\n            let A1B2 = 0;\n            let B1 = 0;\n            let C1 = 0;\n            let C2 = 0;\n            let scaleFactor = 0;\n\n            const position = [0, 0, 0];\n\n            for (let i = ymin; i < ymax; i++) {\n                for (let j = xmin; j < xmax; j++) {\n                    position[0] = j - (WIDTH / 2);\n                    position[1] = (HEIGHT / 2) - i;\n                    if (\n                        j > 0 && (j < WIDTH - 1) &&\n                        i > 0 && (i < HEIGHT - 1) &&\n                        drawable.isTouching(position)\n                    ) {\n                        const address = (i * WIDTH) + j;\n                        const gradT = ((prev[address]) - (curr[address]));\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                        scaleFactor++;\n                    }\n                }\n            }\n\n            const delta = ((A1B2 * A1B2) - (A2 * B1));\n            let u = 0;\n            let v = 0;\n            if (delta) {\n                // system is not singular - solving by Kramer method\n                const deltaX = -((C1 * A1B2) - (C2 * B1));\n                const deltaY = -((A1B2 * C2) - (A2 * C1));\n                const Idelta = 8 / delta;\n                u = deltaX * Idelta;\n                v = deltaY * Idelta;\n            } else {\n                // singular system - find optical flow in gradient direction\n                const Norm = ((A1B2 + A2) * (A1B2 + A2)) + ((B1 + A1B2) * (B1 + A1B2));\n                if (Norm) {\n                    const IGradNorm = 8 / Norm;\n                    const temp = -(C1 + C2) * IGradNorm;\n                    u = (A1B2 + A2) * temp;\n                    v = (B1 + A1B2) * temp;\n                }\n            }\n\n            let activePixelNum = 0;\n            if (scaleFactor) {\n                // store the area of the sprite in pixels\n                activePixelNum = scaleFactor;\n                scaleFactor /= (2 * WINSIZE * 2 * WINSIZE);\n\n                u = u / scaleFactor;\n                v = v / scaleFactor;\n            }\n\n            state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));\n            if (state.motionAmount > LOCAL_MAX_AMOUNT) {\n                // clip all magnitudes greater than 100\n                state.motionAmount = LOCAL_MAX_AMOUNT;\n            }\n            if (state.motionAmount > LOCAL_THRESHOLD) {\n                // Scratch direction\n                state.motionDirection = (((Math.atan2(v, u) * TO_DEGREE) + 270) % 360) - 180;\n            }\n            state.motionFrameNumber = this.frameNumber;\n        }\n    }\n}\n\nmodule.exports = VideoMotion;\n\n\n\n// WEBPACK FOOTER //\n// src/extensions/scratch3_video_sensing/lib.js"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAHA;AAAA;AAKA;AACA;AAAA;AANA;AACA;AAGA;AAAA;AAQA;AAZA;AACA;AAEA;AAAA;AAUA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAJA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAnOA;AACA;AACA;;;;;;AAoOA;;;;;;;;;;;;;;ACtQA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;A","sourceRoot":""}